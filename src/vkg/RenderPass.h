/*
 * Copyright (C) 2020 Jordan Hendl
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* 
 * File:   RenderPass.h
 * Author: Jordan Hendl
 *
 * Created on December 28, 2020, 10:34 AM
 */

#pragma once

namespace vk
{
  class Framebuffer ;
  class RenderPass  ;
  union ClearValue  ;
  class Rect2D      ;
}

namespace nyx
{
  class Attachment ;
  
  /** Forward declared image layout.
   */
  enum class ImageLayout : unsigned ;
  enum class ImageFormat : unsigned ;
  namespace vkg
  {
    class CommandBuffer ;
    class PipelineData ;
    class Image ;
    
    class RenderPass
    {
      public:
        /** Default constructor.
         */
        RenderPass() ;
        
        /** Default deconstructor.
         */
        ~RenderPass() ;
  
        /** Method to initialize this object.
         * @param device The device to use for all GPU operations.
         * @param nyx_file_path The path to the .nyx file on the filesystem to use.
         * @param context The Framework context for this renderer to draw to.
         */
        void initialize( unsigned device ) ;
        
        /** Method to initialize this object.
         * @param device The device to use for all GPU operations.
         * @param nyx_file_bytes The bytes of the .nyx file to use for this object.
         * @param size The size of the bytes array.
         * @param context The Framework context for this renderer to draw to.
         */
        void initialize( unsigned device, unsigned window_id ) ;
        
        /** Method to check whether this object is initialized or not.
         * @return Whether or not this object is initialized.
         */
        bool initialized() const ;

        /** Method to set the dimensions of this render pass's output attachments.
         * @param width The width in pixels of this object's output images.
         * @param height The height in pixels of this object's output images.
         */
        void setDimensions( unsigned width, unsigned height ) ;
        
//        /** Method to add a viewport to this renderer.
//         * @param viewport The viewport to add in the output of this renderer.
//         */
//        void addViewport( const nyx::Viewport& viewport ) ;
  
        /** Method to retrieve the number of framebuffers generated by this renderer.
         * @return The number of framebuffers generated by this renderer.
         */
        unsigned count() const ;
        
        vk::Framebuffer current() const ;
        /** Method to retrieve the device used by this renderer.
         * @return Const reference to the device used for this renderer.
         */
        unsigned device() const ;
        
        unsigned currentIndex() const ;
        bool present() ;
        /** Method to retrieve a framebuffer from this object.
         * @param index The index of framebuffer to retrieve. See @count for the amount.
         * @return Const reference to this object's internal framebuffer.
         */
        const vkg::Image& framebuffer( unsigned index ) const ;
        void reset() ;
        
        void addSubpass( const nyx::Attachment* attachments, unsigned attachment_count, const unsigned* subpass_deps, unsigned num_subpass_deps ) ;

      private:

        friend class vkg::CommandBuffer ;
        friend class vkg::PipelineData  ;

        const vk::Rect2D& area() const ;
        const vk::Framebuffer*  framebuffers() const ;
        const vk::ClearValue*   clearValues() const ;
        const vk::RenderPass& pass() const ;
        struct RenderPassData *render_pass_data ;
        
        RenderPassData& data() ;
        
        const RenderPassData& data() const ;
    };
  }
}

